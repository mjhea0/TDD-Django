## TDD with Django and PyVows


[PyVows](http://heynemann.github.io/pyvows/), is a port of the popular Vows BDD framework from Node.js.  Being from Node it is of course asyncronous.  Being asyncronous it can make test run faster.  It doesn't guarantee test run faster, but it can help, especially if your running GUI tests.  

In this article I'm going to discuss using PyVows for TDD with Django.  The biggest motivation for me to use something like PyVows is to get my GUI Test to run faster.  But wait (I'm often asked) isn't TDD just about Unit Tests?  Well no, not actually.  To quote [Dan North](http://dannorth.net/introducing-bdd/):

> TDD - as originally described - is also about the behavior of entire systems.  Kent Beck
> specifically describes it as operating on multiple levels of abstraction, no just "down in the code"
> ... you can describe different granularities of behavior from the entire applicaiton right 
> down to individual small components, classes or functions. 

So while much of the focus in TDD articles is on unit tests, TDD is about building test that describe the expected functionality of a system and writting code until those tests pass.  Unit Tests are one example, but so are integration, GUI and pretty much any other type of testing.

With the rant out of the way, lets dig into some code.

Start a new Django project (with [virtualenvwrapper](https://bitbucket.org/dhellmann/virtualenvwrapper), [django-pyVows](http://github.com/rafaelcaricio/django-pyvows), and [selenium](https://code.google.com/p/selenium/)):

```shell
$ mkvirtualenv TDD-Django --no-site-packages
New python executable in TDD-Django/bin/python
Installing setuptools............done.
Installing pip...............done.
$ workon TDD-Django 
pip install pyVows django django-pyVows selenium lxml cssselect
...snipped...
$ django-admin.py startproject tddapp      
```

Now that we have a basic project setup lets create our first GUI (aka functional) test to focus our development efforts on our user story.  For this example we will use a typical login user story that says something to the effect of:

>`As a` registered user<br>
>`I want to` login into the application entering a userame and password<br>
>`So that` I can be assured my data is safe.

So to create our first GUI test with pyVows we might add the following to tddapp/uitests.py file. 

```python
from pyvows import Vows, expect

from django_pyvows.context import DjangoHTTPContext
from selenium import webdriver

@Vows.batch
class TDDDjangoApp(DjangoHTTPContext):

    def get_settings(self):
        return "tddapp.settings"

    def topic(self):
        self.start_server()
        browser = webdriver.Firefox()
        browser.get(self.get_url("/"))
        return browser

    def should_prompt_the_user_with_a_login_page(self, topic):
        expect(topic.title).to_include('Login')
```

There are several things going on here, I'll explain the basics but for a detailed explanation of pyVows check out the [github page](http://heynemann.github.io/pyvows/).

The start of the test imports all the neccessary libraries including pyvows, django_pyvows and selenium.

```python
from pyvows import Vows, expect

from django_pyvows.context import DjangoHTTPContext
from selenium import webdriver
```

The next line creates what in pyVows is refered to as a Test batch.  A Test batch is pyVows is identified by the @Vows.batch decorator and is synonomous with `unittest.TestCase` in Python standard library's unittest module.

Test batches are _contexts_ which describe different componenets and states you want to test.  Generally a Test Batch will inherit from `Vows.Context` but in our case we are inheriting from `DjangoHTTPContext` as that class provides all the helper functionality baked into djago_pyvows.  In addition to inheriting from `DjangoHTTPContext` you need to overwrite the function get_settings and return the path to your settings.py file you want to use to run your tests.

```python
@Vows.batch
class TDDDjangoApp(DjangoHTTPContext):

	def get_settings(self):
        	return "tddapp.settings"

``` 

Each Context should contain a single topic which is what you are testing and a number of vows which perform the tests against the topic. For our topic we start the django server using the `start_server()` helper function, fire up Selenium and point selenium to the root of our django application.  _Note: self.get_url("/") translates the relative url to the absolute url, that we need to access the site_  Then, since this is a functional test our topic return the selenium webdriver so we can execute our tests.

Next our first vow or test just checks to see if the title of the page includes 'Login'

```python
def topic(self):
        self.start_server()
        browser = webdriver.Firefox()
        browser.get(self.get_url("/"))
        return browser

    def should_prompt_the_user_with_a_login_page(self, topic):
        expect(topic.title).to_include('Login')
```

Running the test at this point should fail, because the default page in Django has a title of "Welcome to Django".  But it will verify at least that our basic setup is correct and we can go ahead and start coding something.  The output of running the test looks like this:

```shell
$ pyVows -vvv uitests.py 

============
Vows Results
============


    Tdd django app
    ✗ should prompt the user with a login page
        Expected topic(u'Welcome to Django') to include 'Login'
        
		...snipping Traceback to save space...

  ✗ OK » 0 honored • 1 broken (2.489381s)
```

Pay attention to the naming of the tests in the report.  The outermost indented line is the Context (TDDDjangoApp), with each vow / test in that context listed and indented underneath.  This makes reporting and finding defects really easy as it reads like requirements.  Consider the following report:

```shell
$ pyVows -vvv uitests.py 

============
Vows Results
============


    Tdd django app
	on Chrome
    	   ✗ should prompt the user with a login page
        on Firefox
    	   ✗ should prompt the user with a login page
 
		...snipping Traceback to save space...

  ✗ OK » 0 honored • 2 broken (3.119354s)
```

Asyncronous Parallell testing on multiple browsers!  Let's have a look at the the test code:

```python
@Vows.batch
class TDDDjangoApp(DjangoContext):

    
    class OnFirefox(DjangoHTTPContext):
        
        def get_settings(self):
            return "tddapp.settings"

        def topic(self):
            self.start_server(port=8888)
            browser = webdriver.Firefox()
            browser.get(self.get_url("/"))
            return browser

        def should_prompt_the_user_with_a_login_page(self, topic):
            expect(topic.title).to_include('Login')
    
    class OnChrome(DjangoHTTPContext):
        
        def get_settings(self):
            return "tddapp.settings"

        def topic(self):
            self.start_server(port=8887)
            browser = webdriver.Chrome()
            browser.get(self.get_url("/"))
            return browser

        def should_prompt_the_user_with_a_login_page(self, topic):
            expect(topic.title).to_include('Login')
```

In pyVows sibling Context are executed in parallel and nested context are executed sequentially.  Which means TDDDjangoApp would be exectued first, then OnFirefox and OnChrome would be executed in parallel.  We can however remove alot of the duplicate code, by creating a standard set of tests and running those tests against multiple contexts.

```python
def onBrowser(webdriver, port):
    class BrowserTests(DjangoHTTPContext):
    
        def get_settings(self):
            return "tddapp.settings"

        def topic(self):
            self.start_server(port=port)
            browser = webdriver()
            browser.get(self.get_url("/"))
            return browser

        def should_prompt_the_user_with_a_login_page(self, topic):
            expect(topic.title).to_include('Django')

    return BrowserTests

@Vows.batch
class TDDDjangoApp(DjangoContext):


    class OnChrome(onBrowser(webdriver.Chrome, 8887)):
        pass
    
    class OnFirefox(onBrowser(webdriver.Firefox, 8888)):
        pass

    class OnPhantonJS(onBrowser(webdriver.PhantomJS, 8886)):
        pass
```

By using the onBrowser function to create a context bassed upon the data passed in we can write all of our tests once (in the BrowserTests class) and create as many context as we need to execute against.

The estute reader my wonder why however we are calling start_server for every new context.  We actually don't have to do this, but we are working around a limitation of django_pyvows.  Unfourtunatly the `DjangoHTTPContext.start_server()` function creates a single threaded, blocking `CherryPyWSGIServer` which, when running asyncronous ui tests is bad for buisness and performance. In fact for this this set of tests execution time increases from roughly 5 seconds (as written above) to roughly 21 seconds if we only crate one CherryPy server.  

Ideally we would want to only create one server to test against and perhaps
make the server multi-threaded so we don't have to incur the performance
penantly.  So let's see if we can make that happen.  First off let's update the
test code to use pyVows notion of context inheritence so we only have to create
the server once.

```python
def onBrowser(webdriver):
    class BrowserTests(DjangoHTTPContext):
    
        def topic(self):
            browser = webdriver()
            browser.get(self.get_url("/"))
            return browser

        def should_prompt_the_user_with_a_login_page(self, topic):
            expect(topic.title).to_include('Django')

    return BrowserTests

@Vows.batch
class TDDDjangoApp(DjangoHTTPContext):

    def get_settings(self):
        return "tddapp.settings"

    def topic(self):
        self.start_server()

    class OnChrome(onBrowser(webdriver.Chrome)):
        pass
    
    class OnFirefox(onBrowser(webdriver.Firefox)):
        pass

    class OnPhantonJS(onBrowser(webdriver.PhantomJS)):
        pass
```

Notice how the TDDDjangoApp context now calls `start_server()` from it's topic
function and we no longer need to pass in a port to our onBrowser context
creation function.  In such a way we now only instantiate one version of server
and run all tests against that.  This has the advantage of using less resources
and it make the code more portable, if we want to perhaps reuse these tests to
run against a different environment.

To deal with the performance issues it would be nice to be able to pass a
number of threads to the start_server function like `start_server(threads=4)`.
To that end I have submitted a patch <<insert link>> to the project.  In the
meantime we can manually manage the threads to get it to work as such:

```python

```

